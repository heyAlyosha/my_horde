-- Логика  раунда игры
local game_core_round_start = require "main.game.core.round.modules.game_core_round_start"
local game_core_round_step_core = require "main.game.core.round.modules.game_core_round_step.game_core_round_step_core"
local game_core_round_step_start = require "main.game.core.round.modules.game_core_round_step.game_core_round_step_start"
local game_core_round_transfer = require "main.game.core.round.modules.game_core_round_transfer"
local game_core_round_step_result = require "main.game.core.round.modules.game_core_round_step.game_core_round_step_result"
local game_core_round_step_sector_core = require "main.game.core.round.modules.game_core_round_step.game_core_round_step_sector_core"
local game_core_round_step_sector_catch = require "main.game.core.round.modules.game_core_round_step.game_core_round_step_sector_catch"
local game_core_round_step_sector = require "main.game.core.round.modules.game_core_round_step.game_core_round_step_sector"
local game_core_round_response = require "main.game.core.round.modules.game_core_round_response"
local game_content_wheel = require "main.game.content.game_content_wheel"
local color = require("color-lib.color")
local core_layouts = require "main.core.core_layouts"
local timer_linear = require "main.modules.timer_linear"
local game_content_bots = require "main.game.content.game_content_bots"
local game_core_round_step_game_over = require "main.game.core.round.modules.game_core_round_step.game_core_round_step_game_over"
local storage_game = require "main.game.storage.storage_game"
local storage_gui = require "main.storage.storage_gui"
local global_function = require "main.modules.global_function"
local game_core_play = require "main.game.core.game_core_play"
local online_image = require "main.online.online_image"

local url_image_to_cloud = "https://storage.yandexcloud.net/hey-alyosha/chudesa/quests/images/"
local url_music_to_cloud = "https://storage.yandexcloud.net/hey-alyosha/chudesa/quests/sound/"

function init(self)
	msg.post(".", "acquire_input_focus")
	self.active = false

	game_core_round_start.to_start(self)

end

function final(self)
	
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	local message = message or {}
	msg.post(".", "acquire_input_focus")

	if message_id == hash("event") then
		--pprint("GAME EVENT:", message.id)
	end

	if message_id == hash("start_game") then
		-- СТАРТ ИГРЫ
		game_core_round_start.to_start(self)

		-- Если пустое сообщение, берём данные из модуля
		if global_function.is_empty(message) then
			message = storage_game.game.message_start 
		end

		storage_game.game.message_start = message

		local index_player = message.index_player
		local debug = message.debug
		local type = message.type
		local level_id = message.level_id
		local category_id = message.category_id
		local quest_type = message.quest_type
		local quest_resourse = message.quest_resource
		local quest_music = message.quest_music
		local quest = message.quest
		local word = message.word
		local disable_symbols = message.disable_symbols
		local sectors = message.sectors
		local players = message.players
		local animate_start = message.animate_start

		--pprint("START_GAME", category_id, level_id, quest_type, quest_resourse, url_image_to_cloud..quest_resourse,  word, quest)

		if quest_resourse and quest_type ~= "music" then
			-- Вопросы с картинкой или обычные вопросы с фоном
			quest_resourse = url_image_to_cloud..quest_resourse
			msg.post("/loader_gui", "visible", {
				id = "plug", visible = true, value = {
					title = "ЗАГРУЗКА ВОПРОСА...",
					color = color.white,
					icon = false,
				}
			})
			online_image.load(self, quest_resourse, function (self, img, error)
				if error then
					-- Не загрузились ресурсы
					msg.post("/loader_gui", "visible", {
						id = "plug", visible = false,
					})
					if quest_type ~= "text" then
						msg.post("/loader_gui", "visible", {
							id = "plug", visible = true, value = {
								title = "ПРОИЗОШЛА ОШИБКА ПРИ ЗАГРУЗКЕ ЗАДАНИЯ! ПРОВЕРЬ ПОДКЛЮЧЕНИЕ К ИНТЕРНЕТУ ИЛИ СЫГРАЙ В ВОПРОСЫ БЕЗ КАРТИНОК!",
								color = color.white,
								icon = "icon_danger",
								btns = {
									{
										id = "message",
										title = "НАЗАД",
										bg = "button_default_green_",
										value = {
											message_url = "main:/core_screens",
											message_id = "catalog_company"
										}
									},
								},
							}
						})
					else
						-- Обычное задание
						quest_resourse = nil
						msg.post("/loader_gui", "visible", {
							id = "plug", visible = false,
						})
						game_core_round_start.start_round(self, type, level_id, category_id, quest_type, quest, word, disable_symbols, players, sectors, animate_start, index_player, debug, quest_resourse)
					end
				else
					-- Картинки загрузилась без проблем
					msg.post("/loader_gui", "visible", {
						id = "plug", visible = false,
					})

					game_core_round_start.start_round(self, type, level_id, category_id, quest_type, quest, word, disable_symbols, players, sectors, animate_start, index_player, debug, quest_resourse)

				end
			end)
		elseif quest_type == "music" then
			-- ВОпросы  с музыкой
			pprint("storage_game.game.message_start", storage_game.game.message_start)
			self.url_sound = url_music_to_cloud..quest_music

			msg.post("/loader_gui", "visible", {id = "plug", visible = false})
			msg.post("/loader_gui", "visible", {
				id = "plug", visible = true, value = {
					title = "ЗАГРУЗКА МЕЛОДИИ...",
					color = color.white,
					icon = false,
				}
			})

			http.request(self.url_sound, "GET", function(self, id, response)
				local error = online_image.is_error_request(self, response)

				if error then
					-- Ошибка при загрузке
					msg.post("/loader_gui", "visible", {id = "plug", visible = false})
					msg.post("/loader_gui", "visible", {
						id = "plug", visible = true, value = {
							title = "ПРОИЗОШЛА ОШИБКА ПРИ ЗАГРУЗКЕ ЗАДАНИЯ! ПРОВЕРЬ ПОДКЛЮЧЕНИЕ К ИНТЕРНЕТУ ИЛИ СЫГРАЙ В ВОПРОСЫ БЕЗ МЕЛОДИЙ!",
							color = color.white,
							icon = "icon_danger",
							btns = {
								{
									id = "message",
									title = "НАЗАД",
									bg = "button_default_green_",
									value = {
										message_url = "main:/core_screens",
										message_id = "catalog_company"
									}
								},
							},
						}
					})
				else
					-- Записываем мелодию
					local path = go.get("game-room:/game-room_core#sound-quest", "sound")
					resource.set_sound(path, response.response)

					if quest_resourse then
						-- Есть фон
						quest_resourse = url_image_to_cloud..quest_resourse

						online_image.load(self, quest_resourse, function (self, img, error)
							msg.post("/loader_gui", "visible", {
								id = "plug", visible = false,
							})

							if error then
								-- Ошибка с загрузкой фона
								quest_resourse = nil
								game_core_round_start.start_round(self, type, level_id, category_id, quest_type, quest, word, disable_symbols, players, sectors, animate_start, index_player, debug, quest_resourse)
								
							else
								-- Картинка загрузилась без проблем
								game_core_round_start.start_round(self, type, level_id, category_id, quest_type, quest, word, disable_symbols, players, sectors, animate_start, index_player, debug, quest_resourse)

							end
						end)
						
					else
						--Запускаем без фона
						-- Картинки загрузилась без проблем
						msg.post("/loader_gui", "visible", {
							id = "plug", visible = false,
						})
						game_core_round_start.start_round(self, type, level_id, category_id, quest_type, quest, word, disable_symbols, players, sectors, animate_start, index_player, debug, quest_resourse)
					end
				end
			end)
		else
			game_core_round_start.start_round(self, type, level_id, category_id, quest_type, quest, word, disable_symbols, players, sectors, animate_start, index_player, debug, quest_resourse)
		end

	elseif message_id == hash("start_company_level") then
		local level_id = message.level_id
		local category_id = message.category_id

		storage_game.play_message.message = message
		storage_game.play_message.message_id = message_id

		game_core_play.company_level(self, category_id, level_id)

	elseif message_id == hash("start_family") then
		game_core_play.family(self, message)

	elseif message_id == hash("start_tournir") then
		local level_id = message.level_id
		local category_id = message.category_id

		-- Записываем для повтора
		storage_game.play_message.message = message
		storage_game.play_message.message_id = message_id

		game_core_play.tournir(self)

	elseif message_id == hash("start_study") then
		-- Обучение
		game_core_play.study(self)

	elseif message.id  == "get_start_step" then
		-- НАЧАТЬ ХОД
		if self.player and self.player.player_id then
			msg.post("/core_bot", "clear_bot", {player_id = self.player.player_id, bot_id = self.player.bot_id})
		end
		local type = message.type
		local index_player = message.index_player
		local first_step = message.first_step
		game_core_round_step_start.start_step(self, index_player, type, first_step)

	elseif message.id  == "get_round_step_sector_start" then
		-- ЗАПУСК СЕКТОРА (НАСТУПИЛ)
		local sector_id = message.sector_id
		local player_id = message.player_id
		game_core_round_step_sector.start(self, sector_id, player_id)

	elseif message.id  == "get_transfer" then
		-- ПЕРЕДАЧА ПРЕДМЕТОВ
		
		local type = message.type
		local count = message.count
		local player_id = message.player_id
		local player_from_id = message.player_from_id
		local player_to_id = message.player_to_id
		local sector_id = message.sector_id

		if type == "leader_to_player" then
			game_core_round_transfer.score_leader_to_player(self, count, player_id)

		elseif type == "player_to_leader" then
			game_core_round_transfer.score_player_to_leader(self, count, player_id)

		elseif type == "player_to_player" then
			game_core_round_transfer.score_player_to_player(self, count, player_from_id, player_to_id)

		elseif type == "sector_to_player" then
			game_core_round_transfer.score_sector_to_player(self, count, sector_id, player_id)

		elseif type == "sector_preview" then
			game_core_round_transfer.score_sector_preview(self, count, sector_id, player_id)

		end

	elseif message.id  == "get_start_game_over" then
		local player_id = message.player_id
		local type = message.type
		game_core_round_step_game_over.start(self, player_id, type)

	elseif message.id  == "get_round_step_start" then
		local sector = game_content_wheel.get_item(self, message.sector_id)
		local skip_catch = message.skip_catch
		local skip_obereg = message.skip_obereg
		game_core_round_step_sector_core.start(self, sector, skip_catch, skip_obereg)

	elseif message.id  == "set_to_start" then
		local text_tablo = message.text_tablo
		local animate_leader = message.animate_leader
		game_core_round_start.to_start(self, text_tablo, animate_leader)

	elseif message.id  == "obereg" then
		game_core_round_step_sector_catch.obereg(self, message.type, message.confirm)

	elseif message.id  == "open_symbol" then
		local type = "success"
		game_core_round_step_result.success_symbol(self, self.sector, self.player, message.value.symbol, type)

	elseif message.id  == "transfer" then
		game_core_round_transfer.on_event(self, message_id, message)

	elseif message_id == hash("event") and core_layouts.get_data().id == "round_game" then
		game_core_round_step_core.on_event(self, message_id, message)

	elseif message_id == hash("set_active") then
		self.active = message.active

	elseif message_id == hash("full_word") then
		-- Слово целиком
		local word = message.word
		local player_id = message.player or self.player.player_id
		game_core_round_response.word(self, word, player_id)
	end
end

function on_input(self, action_id, action)
	if true and action_id == hash("action_mouse") then

		--[[
		msg.post("main:/loader_gui", "set_status", {
			id ="test_position", 
			type ="set_position", 
			--world_position = go.get_world_position()vmath.vector3(action.x, action.y, 1)
			world_position = go.get_world_position()
		})

		-- Вращение барабана
		msg.post("/loader_gui", "set_content", {
			id = "game_wheel",
			type = "rotate",
			value = {
				procent = 0.25
			}
		})
		--]]

	end

	-- Если неактивна отключаем 
	if not self.active then
		return
	end

	if timer_linear.on_input(self, action_id, action) then
		return true
	end

	-- Классические кнопки
	--pprint(action_id, action.pressed)
	if (action_id == hash("enter") or action_id == hash("back") or action_id == hash("key_esc") or action_id == hash("action") or action_id == hash("action_mouse")) and action.pressed then
		local layout = core_layouts.get_data()

		if layout.id == "start_round" then
			-- Если это начало рауна, сбрасываем все анимации
			--game_core_round_render.start_no_animate(self)
			msg.post("main:/sound", "play", {sound_id = "activate_btn"})

		elseif (action_id == hash("back")) and not storage_gui.components_visible.modal_pause and not storage_gui.components_visible.game_hud_buff_horisontal and not storage_gui.components_visible.modal_reward_score and not storage_gui.components_visible.catalog_prize_magazine then
			-- Пауза
			msg.post("main:/sound", "play", {sound_id = "activate_btn"})
			msg.post("main:/loader_gui", "visible", {
				id = "modal_pause",
				visible = true,
				type = hash("popup")
			})
		end

	elseif action_id == hash("up") and action.pressed then
		

	elseif action_id == hash("down") and action.pressed then
		

	elseif action_id == hash("left") and action.pressed then
		

	elseif action_id == hash("right") and action.pressed then
		

	elseif action_id == hash("back") and action.pressed then
		

	elseif not action_id and action.x and action.y and self.btns then
		
	end
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end

local storage_game = require "main.game.storage.storage_game"
local core_layouts = require "main.core.core_layouts"

function init(self)
	self.max_symbols = 13
	self.margin_tablo = 5
	--self.scale = go.get_scale()
	self.scale = vmath.vector3(0.85)
	self.margin_tablo = 5 * self.scale.x

	self.symbols = {}

	-- Удаляем тестовые таблички с буквами
	for i = 1, self.max_symbols do
		go.delete("tablo"..i)
	end
end

function final(self)
	
end

function on_message(self, message_id, message, sender)
	if message_id == hash("create_tablo") then
		-- Создаётся слово на табло
		-- Удаляем старое слово, если было
		for i = 1, #self.symbols do
			local item = self.symbols[i]

			go.delete(item.url)
			self.symbols[i] = nil
		end

		local word = message.word or ""
		word = utf8.lower(word)

		local all_size = 0
		local start_position = go.get_position()
		local row = 1
		local table = {}
		local line_size = {}

		for symbol in utf8.gmatch(word, ".") do
			symbol = utf8.upper(symbol)
			-- Обрабатываем пробел и тире в ответе
			local open = symbol == " " or symbol == "-"
			if symbol == " " then
				symbol = "_"
			elseif symbol == "-" then
				symbol = "-"
			end

			local go_tablo = factory.create("#tablo_factory", nil)

			go.set_scale(2, "/scene_tablo")

			local sprite_url = msg.url(nil, go_tablo, "bg_close")
			local label_url = msg.url(nil, go_tablo, "label")

			label.set_text(label_url, utf8.upper(symbol))

			local size = go.get(sprite_url, "size.x") * self.scale.x
			local height = go.get(sprite_url, "size.y") * self.scale.y

			local position = vmath.vector3(start_position.x + all_size + size + self.margin_tablo, start_position.y, 3)
			go.set_position(position, go_tablo)

			all_size = all_size + size + self.margin_tablo

			if open then
				go.set_rotation(vmath.quat_rotation_y(0), go_tablo)
			else
				go.set_rotation(vmath.quat_rotation_y(3.141592653), go_tablo)
			end

			-- Добавляю  
			self.symbols[#self.symbols + 1] = {
				url = go_tablo,
				sprite_url = sprite_url,
				label_url = label_url,
				symbol = symbol,
				open = open,
				row = row
			}

			line_size[row] = all_size

			-- Определяем строки для многословных ответов
			if symbol == "-" or symbol == "_" then
				start_position.y = start_position.y - height - self.margin_tablo
				
				all_size = 0
				row = row + 1
			end

			table[row] = table[row] or 0
			table[row] = table[row] + 1

		end

		-- Центрируем табло
		for i = 1, #self.symbols do
			--local size = go.get(item.url, "size.y") * self.scale.y
			--local height_y = (row - 1) * size /2
			local item = self.symbols[i]

			local position = go.get_position(item.url)
			position.y = position.y + (row - 1) * 30
			position.x = position.x - ((line_size[item.row] + line_size[item.row] / table[item.row]) / 2)

			if item.row == 1 then
				position.x = position.x + self.margin_tablo * 2
			end

			go.set_position(position, item.url)
		end

		-- Записываем данные в игровое хранилище
		storage_game.game.round.tablo = self.symbols

	elseif message_id == hash("open_symbol") then
		--Открытие символа на табло
		local layout = core_layouts.get_data()
		local symbol = message.symbol or ""
		local is_sound = message.is_sound
		if message.is_sound == nil then
			is_sound = true
		end

		symbol = utf8.lower(symbol)

		-- Если нет в открытых букв для игры
		local disable_symbols = storage_game.game.round.disable_symbols or {}

		local is_disable_symbol
		
		for i, open_symbol in ipairs(disable_symbols) do
			if utf8.lower(open_symbol) == symbol then
				is_disable_symbol = true
				break
			end
		end

		if not is_disable_symbol then
			table.insert(storage_game.game.round.disable_symbols, symbol)
		end

		if is_sound then
			msg.post("main:/sound", "play", {sound_id = "response-success"})
			msg.post("main:/sound", "play", {sound_id = "ovation_success"})
		end

		-- Массив для открытия букв на табло
		local openes = {}
		for i = 1, #self.symbols do
			local item = self.symbols[i]

			if utf8.lower(item.symbol) == symbol and not item.open then
				openes[#openes + 1] = item
				self.symbols[i].open = true

				-- Если это режим звёзбд в миссии с открытием букв на табло
				if storage_game.stars.type == "symbol" and layout.data.index_player then
					local player = storage_game.game.players[layout.data.index_player]

					if player.player_id == "player" then
						local value = 1
						local operation = "add"
						msg.post("main:/core_stars", "update", {
							value = value, operation = operation
						})
					end
				end

			end
		end

		-- Начинаем открывать
		local time = 0
		local time_animation = 0.25

		msg.post("main:/sound", "play", {sound_id = "game_result_trophys_1"})

		for i = 1, #openes do
			local item = openes[i]
			local scale = go.get_scale(item.url)

			timer.delay(time, false, function (self)
				msg.post("main:/sound", "play", {sound_id = "game_result_trophys_1"})
			end)

			go.animate(item.url, "scale", go.PLAYBACK_ONCE_PINGPONG, scale * 1.2, go.EASING_LINEAR, time_animation, time)
			go.animate(item.url, "rotation", go.PLAYBACK_ONCE_FORWARD, vmath.quat_rotation_y(0), go.EASING_LINEAR, time_animation, time)

			time = time + time_animation + 0.25
			item.open = true
		end

		storage_game.game.round.tablo = self.symbols

		-- Проверяем остались ли закрытые буквы
		for i = 1, #self.symbols do
			local item = self.symbols[i]

			if not item.open then
				return
			end
		end

		-- Если не остались, отправляем сообщение, что все октрыты
		timer.delay(time, false, function ()
			msg.post(sender, "word_open")

		end)

	elseif message_id == hash("open_word") then
		-- Массив для открытия букв на табло
		local openes = {}
		for i = 1, #self.symbols do
			local item = self.symbols[i]

			if not item.open then
				openes[#openes + 1] = item
				self.symbols[i].open = true
			end
		end

		-- Начинаем открывать
		local time = 0
		local time_animation = 0.25
		msg.post("main:/sound", "play", {sound_id = "game_result_trophys_1"})
		for i = 1, #openes do
			local item = openes[i]
			local scale = go.get_scale(item.url)

			
			timer.delay(time, false, function (self)
				msg.post("main:/sound", "play", {sound_id = "game_result_trophys_1"})
			end)

			go.animate(item.url, "scale", go.PLAYBACK_ONCE_PINGPONG, scale * 1.2, go.EASING_LINEAR, time_animation, time)
			go.animate(item.url, "rotation", go.PLAYBACK_ONCE_FORWARD, vmath.quat_rotation_y(0), go.EASING_LINEAR, time_animation, time)

			time = time + time_animation + 0.25
			item.open = true
		end
	end
end

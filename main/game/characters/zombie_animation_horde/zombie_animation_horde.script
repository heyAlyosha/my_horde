go.property("index", 1)
go.property("speed", 50)
go.property("skin_id", 0)
go.property("human_id", 1)
go.property("parent", msg.url())
go.property("distantion_player", 5)

function init(self)
	character_animations.play(self, "move")

	self.position_parent = go.get_position(self.parent)

	self.horde_position = horde.get_position(self, self.position_parent, self.index)
	self.dir = self.horde_position - self.position_parent 
	self.dir = self.dir + vmath.normalize(self.dir) * self.distantion_player
	self.point_count = 16
	self.position_start = self.position_parent + self.dir

	local result_collision = physics.raycast(self.position_start, self.position_parent, {hash("default")}, options)

	-- Создаём точки вокруг
	self.points_move = {}
	for i = 1, self.point_count do
		self.rot = vmath.quat_rotation_z(3.141592563 * 2 / self.point_count * i)
		-- Точка следования
		local position_to = position_functions.go_get_perspective_z(vmath.rotate(self.rot, self.dir) + self.position_parent)
		-- Есть ли колиизии на точке следования
		local result_collision = physics.raycast(self.position_parent, position_to, {hash("default")}, options)
		--print("result_collision", result_collision)
		if result_collision then
			position_to = position_functions.go_get_perspective_z(result_collision.position)
		end

		-- Поворот персонажа
		local position_from
		if i == 1 then
			position_from = self.position_start
		else
			position_from = self.points_move[i - 1].position_to
		end
		local dir = position_to - position_from

		self.points_move[i] = {
			position_to = position_to,
			hflip = dir.x < 0
		}
	end

	local function circle_move(self)
		self.index_point = self.index_point + 1
		if self.index_point > self.point_count then
			self.index_point = 1
		end

		local position_to = self.points_move[self.index_point].position_to
		sprite.set_hflip("#body", self.points_move[self.index_point].hflip)
		go.animate(".", "position", go.PLAYBACK_ONCE_FORWARD, position_to, go.EASING_LINEAR, self.duration)
	end

	self.duration = vmath.length(self.points_move[2].position_to - self.points_move[1].position_to) / self.speed
	--self.duration = 0.5
	if vmath.length(self.position_start - go.get_position()) > 1 then
		ai_move.move_to_position(self, self.horde_position, function (self)
			self.index_point = 1
			circle_move(self)
			timer.delay(self.duration, true, circle_move)
		end, handle_error)
	else
		self.index_point = 1
		circle_move(self)
		timer.delay(self.duration, true, circle_move)
	end 
end

function final(self)

end

function on_message(self, message_id, message, sender)
	if message_id == hash("contact_point_response") then
		
	end
	
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end

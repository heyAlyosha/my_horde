go.property("animate", true)

function init(self)
	self.urls = {
		shadow = "shadow#shadow"
	}

	self.positions_cloud = {}

	-- Затемнение
	go.set(self.urls.shadow, "tint.w", 0)

	-- Облака и грозы
	for i = 1, 3 do
		self.urls["cloud"..i] = "cloud"..i
		self.urls["cloud_sprite"..i] = "cloud"..i .. "#body"
		self.urls["lightning"..i] = "cloud"..i .. "#lightning"

		local url_cloud = self.urls["cloud"..i]
		local url_cloud_sprite = self.urls["cloud_sprite"..i]
		local url_lightning = self.urls["lightning"..i]

		-- Стартовое рамоложение
		self.positions_cloud[i] = go.get_position(url_cloud)

		-- Отключаем молнии и облака
		msg.post(url_lightning, "disable")
		go.set(url_cloud_sprite, "tint.w", 0)

		local position = go.get_position(url_cloud)

		-- Раздвигаем облака
		if i == 1 then
			position.x = position.x - 300
			go.set_position(position, url_cloud)
		elseif i == 3 then
			position.x = position.x + 300
			go.set_position(position, url_cloud)
		end
	end

	-- Анимация появления облаков
	self.delay_animation = 0.5
	self.duration = 0.25
	go.animate(self.urls.shadow, "tint.w", go.PLAYBACK_ONCE_FORWARD, 0.5, go.EASING_LINEAR, self.duration)

	timer.delay(self.delay_animation, false, function (self)
		for i = 1, 3 do
			local url_cloud = self.urls["cloud"..i]
			local url_cloud_sprite = self.urls["cloud_sprite"..i]

			go.animate(url_cloud, "position", go.PLAYBACK_ONCE_FORWARD, self.positions_cloud[i], go.EASING_OUTCUBIC, self.duration)
			go.animate(url_cloud_sprite, "tint.w", go.PLAYBACK_ONCE_FORWARD, 1, go.EASING_LINEAR, self.duration)

			--Анимация плавания облаков
			timer.delay(self.duration, false, function (self)
				local position_y = self.positions_cloud[i].y
				if i == 1 then
					position_y = position_y + 3
				elseif i == 2 then
					position_y = position_y - 6
				else
					position_y = position_y - 3
				end
				go.animate(url_cloud, "position.y", go.PLAYBACK_LOOP_PINGPONG, position_y, go.EASING_LINEAR, 1)
			end)
		end
	end)
	if true then
		return true
	end

	-- Анимация грозы
	self.duration_lightning = 0.1
	self.timer_lightning = timer.delay(1, true, function (self)
		local lightning_sprite = {"lightning_2", "lightning_3"}
		for i = 1, 3 do
			math.randomseed(i)
			if math.random(0, 1) == 1 then
				local url_lightning = self.urls["lightning"..i]
				local sprite = lightning_sprite[math.random(1, 2)]
				gui.set_enabled(url_lightning, true)
				gui.play_flipbook(url_lightning, sprite)
				gui.set_color(self.urls.shadow, vmath.vector4(0, 0, 0, 0.3))

				timer.delay(self.duration_lightning/2, false, function (self)
					if math.random(0, 1) == 1 then
						timer.delay(self.duration_lightning/2, false, function (self)
							if sprite == 1 then
								sprite = lightning_sprite[2]
							else 
								sprite = lightning_sprite[1]
							end

							gui.play_flipbook(url_lightning, sprite)

							timer.delay(self.duration_lightning/2, false, function (self)
								gui.set_enabled(url_lightning, false)
								gui.set_color(self.urls.shadow, vmath.vector4(0, 0, 0, 0.5))
							end)
						end)
					else
						gui.set_enabled(url_lightning, false)
						gui.set_color(self.urls.shadow, vmath.vector4(0, 0, 0, 0.5))
					end
				end)
			end
		end
	end)
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Learn more: https://defold.com/manuals/message-passing/
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end

-- Скрипты для карты
function init(self)
	-- Объекты для активации
	self.activation_objects = {}

	sprite.play_flipbook("door_exit#body", hash("door_open"))

	storage_gui.core_screens.visible_shop = false
	msg.post("main:/core_screens", "game")

	msg.post(".", "init")

	--msg.post(".", "start")
	msg.post(".", "test")
	
end

function final(self)
	-- Add finalization code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function update(self, dt)
	levels_script_functions.on_update(self)
end

function fixed_update(self, dt)
	-- This function is called if 'Fixed Update Frequency' is enabled in the Engine section of game.project
	-- Can be coupled with fixed updates of the physics simulation if 'Use Fixed Timestep' is enabled in
	-- Physics section of game.project
	-- Add update code here
	-- Learn more: https://defold.com/manuals/script/
	-- Remove this function if not needed
end

function on_message(self, message_id, message, sender)
	if message_id == hash("init") then
		-- Инициализация карты
		camera.follow(camera_id, msg.url("player"), options)

	elseif message_id == hash("test") then
		-- Тестируем
		camera.follow(camera_id, msg.url("player"), options)
		msg.post("player", "activate")
		msg.post(".", "activation_point", {id_activation = hash("left_palat")})
		msg.post(".", "activation_point", {id_activation = hash("two_room")})
		
		
	elseif message_id == hash("start") then
		-- Игрок идёт до стартовой точки уровня
		local position_to = go.get_position("start_point")
		position_to = position_functions.add_perspective_z(position_to)
		msg.post("player", "position_to", {position_to = position_to})

	elseif message_id == hash("player_position_success") then
		-- Игрок дошёл до стартовой точки
		msg.post("player", "activate")

	elseif message_id == hash("activation_point") and message.id_activation == hash("first_room_end") then
		-- Конец первой комнаты
		-- Блокируют выход
		local duration = 1
		go.animate("bed_hospital_first_room", "position.x", go.PLAYBACK_ONCE_FORWARD, go.get_position("bed_hospital_first_room").x - 50, go.EASING_LINEAR, duration)
		sprite.play_flipbook("bed_human_two_room#body", "human_1_walking")
		go.animate("bed_human_two_room", "position.x", go.PLAYBACK_ONCE_FORWARD, go.get_position("bed_human_two_room").x - 50, go.EASING_LINEAR, duration)
		sprite.play_flipbook("bed_human_two_room1#body", "human_2_walking")
		go.animate("bed_human_two_room1", "position.x", go.PLAYBACK_ONCE_FORWARD, go.get_position("bed_human_two_room").x - 50, go.EASING_LINEAR, duration)

		-- Убегают
		timer_linear.add(self, "start", 1, function (self)
			duration = 7
			sprite.play_flipbook("bed_human_two_room#body", "human_1_running")
			sprite.set_hflip("bed_human_two_room#body", false)
			go.animate("bed_human_two_room", "position.x", go.PLAYBACK_ONCE_FORWARD, go.get_position("bed_human_two_room").x + 300, go.EASING_LINEAR, duration)
			sprite.play_flipbook("bed_human_two_room1#body", "human_2_running")
			sprite.set_hflip("bed_human_two_room1#body", false)
			go.animate("bed_human_two_room1", "position.x", go.PLAYBACK_ONCE_FORWARD, go.get_position("bed_human_two_room").x + 300, go.EASING_LINEAR, duration)
		end, delay)

		-- Начинают ломать дверь
		timer_linear.add(self, "start", 2, function (self)
			camera.unfollow()
			local position_to = go.get_position("door_first_room_right")

			go.animate("camera", "position", go.PLAYBACK_ONCE_FORWARD, position_to, go.EASING_OUTCUBIC, 1, 0)

			go.set("player#script", "active_input", false)
		end, delay)

		timer_linear.add(self, "start", 1, function (self)
			msg.post("door_first_room_right", "damage", {damage = 1})
			msg.post("door_first_room_left", "damage", {damage = 1})
		end, delay)

		timer_linear.add(self, "start", 0.5, function (self)
			msg.post("door_first_room_right", "damage", {damage = 1})
			msg.post("door_first_room_left", "damage", {damage = 1})
		end, delay)

		timer_linear.add(self, "start", 0.5, function (self)
			msg.post("door_first_room_right", "damage", {damage = 1})
			msg.post("door_first_room_left", "damage", {damage = 1})
		end, delay)

		timer_linear.add(self, "start", 0.5, function (self)
			msg.post("door_first_room_right", "damage", {damage = 1000})
			msg.post("door_first_room_left", "damage", {damage = 1000})
		end, delay)

		-- Поялвляются зомби
		timer_linear.add(self, "start", 0.5, function (self)
			msg.post(".", "activation_point", {id_activation = hash("first_room")})
		end, delay)

		-- Цели зомбики
		timer_linear.add(self, "start", 0.1, function (self)
			local goals = {msg.url("first_room_zombie"), msg.url("first_room_zombie1")}
			levels_script_functions.add_goal_ruins(self, goals, function (self)
				msg.post(".", "activation_point", {id_activation = hash("two_room")})
				timer.delay(0.5, false, function (self)
					-- Зомбики убиты
					-- Цель - кровать 
					local goals = {msg.url("bed_hospital_first_room")}
					levels_script_functions.add_goal_ruins(self, goals, function (self)
						timer.delay(1, false, function (self)
							local goals = {msg.url("bed_exit")}
							levels_script_functions.add_goal_ruins(self, goals, function (self)
								timer.delay(1, false, function (self)
									-- После уничтожения последней кровати - поражение
									msg.post("#map_core", "win", {
										point_win = msg.url("win_point")/nil, -- Точке для анимации победы игрока
										next_level_point = msg.url("next_level_point")/nil -- Точка куда убегает игро после закрытия реузльтатов уровня
									})
								end)
							end)
							
						end)
					end)
				end)
			end)
		end, delay)

		
		timer_linear.add(self, "start", 1, function (self)
			go.animate("camera", "position", go.PLAYBACK_ONCE_FORWARD, go.get_position("player"), go.EASING_OUTCUBIC, 0.5, 0, function (self)
				go.set("player#script", "active_input", true)
				camera.follow(camera_id, msg.url("player"), options)
			end)
		end, delay)

	elseif message_id == hash("add_activation_object") then
		-- Добавляем объект в активацию
		local id_activation = message.id_activation
		self.activation_objects[id_activation] = self.activation_objects[id_activation] or {}
		table.insert(self.activation_objects[id_activation], sender)

	elseif message_id == hash("activation_point") then
		-- Активация объектов по поинту
		local id_activation = message.id_activation
		if self.activation_objects[id_activation] then
			for i, url in ipairs(self.activation_objects[id_activation]) do
				msg.post(url, "activation")
			end
		end
	end
end

function on_input(self, action_id, action)
	-- Add input-handling code here. The game object this script is attached to
	-- must have acquired input focus:
	--
	--    msg.post(".", "acquire_input_focus")
	--
	-- All mapped input bindings will be received. Mouse and touch input will
	-- be received regardless of where on the screen it happened.
	-- Learn more: https://defold.com/manuals/input/
	-- Remove this function if not needed
end

function on_reload(self)
	-- Add reload-handling code here
	-- Learn more: https://defold.com/manuals/hot-reload/
	-- Remove this function if not needed
end

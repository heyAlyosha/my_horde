local druid = require("druid.druid")
local gui_input = require "main.gui.modules.gui_input"
local gui_animate = require "main.gui.modules.gui_animate"
local storage_gui = require "main.storage.storage_gui"
local gui_manager = require "main.gui.modules.gui_manager"
local game_wheel_functions = require "main.gui.game_gui.game_wheel.functions.game_wheel_functions"
local game_wheel_render = require "main.gui.game_gui.game_wheel.functions.game_wheel_render"
local game_wheel_objects = require "main.gui.game_gui.game_wheel.functions.game_wheel_objects"
local color = require("color-lib.color")
local storage_game = require "main.game.storage.storage_game"
local gui_loyouts = require "main.gui.modules.gui_loyouts"
local gui_lang = require "main.lang.gui_lang"

function init(self)
	self.id = "game_wheel"
	--msg.post(".", "acquire_input_focus")
	gui_manager.add_screen(self.id, msg.url())
	gui.set_render_order(1)

	self.active = false
	--gui_extra_functions.init()

	self.nodes = {
		wrap = gui.get_node("wrap"),
		sector_for_clone = gui.get_node("sector_template/wrap"),
		table_text = gui.get_node("table_text"),
		aim = gui.get_node("aim"),
		wheel = gui.get_node("wheel"),
		wheel_wrap = gui.get_node("wheel_wrap"),
		object = gui.get_node("object"),
		ray = gui.get_node("ray_template/ray"),
		wrap_objects = gui.get_node("wrap_objects"),
		wheel_wrap_study = gui.get_node("wheel_wrap_study")
	}
	self.game_wheel_render = game_wheel_render

	storage_gui.data.game.position_wheel = gui.get_screen_position(self.nodes.wheel_wrap)

	self.druid = druid.new(self)

	game_wheel_render.start(self)
	
end

function final(self)
	msg.post("/loader_gui", "visible", {
		visible = false, 
		id = "bg", 
		parent_id = self.id,
	})

	gui_manager.remove_screen("game_wheel", msg.url())
	self.druid:final()
	gui_input.on_final(self)	
end

function update(self, dt)
	self.druid:update(dt)

	if self.rotate or self.animate_focus_wheel or self.visible_focus_wheel then
		game_wheel_objects.render_all(self)
		storage_gui.data.game.position_wheel = gui.get_screen_position(self.nodes.wheel_wrap)
		game_wheel_functions.set_screen_position(self)
	end
end

function on_message(self, message_id, message, sender)
	input_remote_tv.on_message(self, message_id, message, sender)
	self.druid:on_message(message_id, message, sender)
	gui_loyouts.on_message(self, message_id, message)

	if message_id == hash("layout_changed") then
		game_wheel_render.layout_changed(self, message)

	elseif message_id == hash("focus") then
		gui_input.set_focus(self, message.focus)

	elseif message_id == hash("visible") then
		--game_wheel_functions.visible(self, message.player_id)

	elseif message_id == hash("window_resize") then
		storage_gui.data.game.position_wheel = gui.get_screen_position(self.nodes.wheel_wrap)
		game_wheel_functions.set_screen_position(self)

	elseif message_id == hash("hidden") then
		gui_animate.hidden_bottom(self, self.nodes.wrap, function (self)
			msg.post("/loader_gui", "visible", {
				id = "game_wheel",
				visible = false,
			})
		end)

	elseif message_id == hash("set_status") then
		if message.type == "update_sectors" then
			-- Обновляем сектора
			game_wheel_render.update_sectors(self)

		elseif message.type == "visible_aim" then
			local data = message.value or {}
			game_wheel_render.aim(self, data.player_id, data.size)
			gui_loyouts.set_enabled(self, self.nodes.aim, message.visible)

		elseif message.type == "preview_aim" then
			-- Превьюшка для прицела
			local data = message.value or {}
			local speed = data.speed
			local size = data.size

			pprint(message)

			if message.visible then
				game_wheel_render.preview_aim(self, speed, size)

			elseif not message.visible and self.animation_caret_preview then
				self.animation_caret_preview.stop(self)

			end

			gui_loyouts.set_enabled(self, self.nodes.aim, message.visible)

		elseif message.type == "preview_artifact" then
			--Превью артефакта
			local data = message.value or {}
			game_wheel_render.preview(self, message.visible, data.artifact_id, data.player_id, data.sector_id)

		elseif message.type == "ray_object" then
			local data = message.value or {}
			game_wheel_functions.ray_object(self, self.sectors[data.sector_id], data.color)

		elseif message.type == "focus_wheel" then
			local data = message.value or {}
			game_wheel_functions.focus_wheel(self, message.visible, data.type, game_wheel_objects)

		elseif message.type == "reset" then
			local data = message.value or {}
			game_wheel_render.reset(self, data.sectors)

		elseif message.type == "study" then
			local data = message.value or {}
			game_wheel_render.study(self, data.id)

		end

		--pprint(message.type)
		--pprint("study_aim")

	elseif message_id == hash("set_content") then
		if message.type == "aim" then
			-- Запись расположения прицела
			local procent = message.value.procent
			game_wheel_functions.rotate_aim(self, procent)

		elseif message.type == "rotate" then
			-- Крутим барабан
			local procent = message.value.procent
			game_wheel_functions.rotate_aim(self, procent)
			game_wheel_functions.rotate(self, game_wheel_functions.get_aim(self).random_rotate, game_wheel_render)

		elseif message.type == "artifact" then
			local data = message.value or {}
			game_wheel_functions.add_artifact(self, data.sector_id, data.player_id, data.artifact_id, game_wheel_render, game_wheel_objects)

		end
	end
end

function on_input(self, action_id, action)
	action_id, action = input_remote_tv.on_input(self, action_id, action)
	if not self.active then
		return
	end

	self.procent = self.procent or 0
	if action_id == hash("left") then
		self.procent = self.procent - 0.001
		msg.post("/loader_gui", "set_content", {
			id = "game_wheel",
			type = "aim",
			value = {
				procent = self.procent
			}
		}) 

	elseif action_id == hash("right") then
		self.procent = self.procent + 0.001
		msg.post("/loader_gui", "set_content", {
			id = "game_wheel",
			type = "aim",
			value = {
				procent = self.procent
			}
		}) 

	elseif action_id == hash("enter") then
		msg.post("/loader_gui", "set_content", {
			id = "game_wheel",
			type = "rotate",
			value = {
				procent = self.procent
			}
		}) 

	elseif action_id == hash("up") then
		msg.post("/loader_gui", "set_status", {
			id = "game_wheel",
			type = "update_sectors",
		})
	end

	self.druid:on_input(action_id, action)
	if action_id == hash("up") and action.pressed then
		if self.focus_btn_id and self.btns[self.focus_btn_id].section == "card_1" then
			msg.post("/loader_gui", "focus", {
				id = "interface", -- id компонента в лоадер гуи
				focus = 1 -- кнопка фокуса
			})

		elseif self.focus_btn_id and self.btns[self.focus_btn_id].section == "body" then
			for i, item in ipairs(self.btns) do
				if not item.disabled and item.section == "card_1" then
					return gui_input.set_focus(self, i)
				end
			end
		end

	elseif action_id == hash("down") and action.pressed then
		
	end

	return gui_input.on_input(self, action_id, action, function_focus, game_wheel_functions.activate_btn, function_back)
end
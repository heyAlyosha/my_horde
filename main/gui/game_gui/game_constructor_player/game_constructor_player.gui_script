local druid = require("druid.druid")
local gui_input = require "main.gui.modules.gui_input"
local storage_gui = require "main.storage.storage_gui"
local storage_player = require "main.storage.storage_player"
local gui_animate = require "main.gui.modules.gui_animate"
local game_constructor_player_selects = require "main.gui.game_gui.game_constructor_player.modules.game_constructor_player_selects"
local gui_manager = require "main.gui.modules.gui_manager"
local game_content_levels = require "main.game.content.game_content_levels"
local game_content_text = require "main.game.content.game_content_text"
local gui_render = require "main.gui.modules.gui_render"
local gui_size = require 'main.gui.modules.gui_size'
local api_player = require 'main.game.api.api_player'
local gui_loyouts = require "main.gui.modules.gui_loyouts"
local gui_lang = require "main.lang.gui_lang"
local nakama_api_account = require "main.online.nakama.api.nakama_api_account"
local censoored_csv = require "main.core.censoored.censoored_csv"
local sound_render = require "main.sound.modules.sound_render"
local game_constructor_player_render = require "main.gui.game_gui.game_constructor_player.modules.game_constructor_player_render"
local storage_game = require "main.game.storage.storage_game"

function init(self)
	msg.post(".", "acquire_input_focus")
	gui.set_render_order(7)
	self.id = "game_constructor_player"
	self.is_modal = true
	gui_manager.add_screen(self.id, msg.url())

	self.nodes = {
		wrap = gui.get_node("wrap"),
		title = gui.get_node("title"),

		wrap_settings_gamer = gui.get_node("wrap_settings_gamer"),
		wrap_settings_bot = gui.get_node("wrap_settings_bot"),

		type_title = gui.get_node("type_template/title"),
		type_value = gui.get_node("type_template/select_template/text"),
		avatar_title = gui.get_node("avatar_template/title"),
		avatar_value = gui.get_node("avatar_template/color_template/pie"),
		color_title = gui.get_node("color_template/title"),
		color_box = gui.get_node("color_template/color_template/pie"),

		name_title = gui.get_node("name_template/title"),

		bot_title = gui.get_node("bot_template/title"),
		bot_value = gui.get_node("bot_template/color_template/pie"),
		bot_name = gui.get_node("bot_name"),
		bot_complexity = gui.get_node("bot_complexity"),
		bot_character = gui.get_node("bot_character"),

		btn_close = gui.get_node("btn-close-template/btn"),
		btn_close_icon = gui.get_node("btn-close-template/btn_icon"),

		btn_save = gui.get_node("save-template/btn_wrap"),
		btn_save_title = gui.get_node("save-template/btn_title"),
	}


	gui_lang.set_text_upper(self, self.nodes.bot_title, "_bot", "", ":")
	gui_lang.set_text_upper(self, self.nodes.avatar_title, "_avatar", "", ":")
	gui_lang.set_text_upper(self, self.nodes.name_title, "_name_to_game", "", ":")
	gui_lang.set_text_upper(self, self.nodes.color_title, "_color", "", ":")
	gui_lang.set_text_upper(self, self.nodes.type_title, "_type_gamer", "", ":")
	gui_lang.set_text_upper(self, self.nodes.btn_save_title, "_save")

	self.druid = druid.new(self)

	msg.post("/loader_gui", "visible", {
		id = "bg",
		visible = true,
		parent_id = self.id,
		value = {order = 5},
		type = hash("animated_close"),
	})
end

function final(self)
	msg.post("/loader_gui", "visible", {
		id = "bg",
		parent_id = self.id,
		visible = false,
		type = hash("animated_close"),
		value = {order = 5}
	})

	gui_manager.remove_screen(self.id, msg.url())
	self.druid:final()
	gui_input.on_final(self)
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	input_remote_tv.on_message(self, message_id, message, sender)
	gui_loyouts.on_message(self, message_id, message)
	self.druid:on_message(message_id, message, sender)
	pprint("on_message", message_id, message)

	if message_id == hash("focus") then
		gui_input.set_focus(self, message.focus)

	elseif message_id == hash("visible") then
		-- Показываем окно
		local data = message.value
		self.player_index = message.player_index
		gui_animate.show_bottom(self, self.nodes.wrap , nil)
		game_constructor_player_render.render(self, self.player_index, game_constructor_player_selects)

		gui_lang.set_text_upper(self, self.nodes.title, "_settings_player", nil, " "..self.player_index)

		timer.delay(0.1, false, function (self)
			gui_input.set_focus(self, 2)
		end)

	

	elseif message.type == "input_keyboard" then
		-- Нажатие на виртуальную клавиатуру
		if message.key == "set_symbol" then
			local symbol = message.value
			local new_string = self.btns_id.edit_name.input:get_text() .. symbol
			self.btns_id.edit_name.input:set_text(new_string)

		elseif message.key == "delete_symbol" then
			local new_string = utf8.sub(self.btns_id.edit_name.input:get_text(), 1, -2)
			self.btns_id.edit_name.input:set_text(new_string)

		elseif message.key == "space" then
			local new_string = self.btns_id.edit_name.input:get_text() .. " "
			self.btns_id.edit_name.input:set_text(new_string)

		elseif message.key == "close" then
		end 

		-- Пришло сообщение
	elseif message_id == hash("set_status") then

	end
end

function on_input(self, action_id, action)
	action_id, action = input_remote_tv.on_input(self, action_id, action)
	self.druid:on_input(action_id, action)

	function function_back(self)
		msg.post("/loader_gui", "set_status", {id = "game_constructor", type = "update"})
		msg.post("/loader_gui", "visible", {
			id = "keyboard_ru",
			visible = false,
		})
		gui_animate.hidden_bottom(self, self.nodes.wrap, function (self)
			msg.post("/loader_gui", "visible", {
				id = self.id,
				visible = false
			})
			
		end)
	end

	-- Нажатие на кнопки
	local function function_activate(self, focus_btn_id)
		local btn = self.btns[focus_btn_id]

		-- Кнопка заблокирована
		if btn.disabled then
			return false
		end
		
		local node = btn.node or btn.wrap_node or btn.node_bg
		gui_animate.activate(self, node)
		msg.post("main:/sound", "play", {sound_id = "activate_btn"})

		if btn.id == "close" or btn.id == "save" then
			function_back(self)

		elseif btn.id == "prev_type" then
			game_constructor_player_selects.listen_type(self, "left")
			msg.post("/loader_gui", "visible", {
				id = "keyboard_ru",
				visible = false,
			})

		elseif btn.id == "next_type" then
			game_constructor_player_selects.listen_type(self, 'right')
			msg.post("/loader_gui", "visible", {
				id = "keyboard_ru",
				visible = false,
			})

		elseif btn.id == "prev_color" then
			game_constructor_player_selects.listen_color(self, "left")

		elseif btn.id == "next_color" then
			game_constructor_player_selects.listen_color(self, 'right')

		elseif btn.id == "prev_avatar" then
			game_constructor_player_selects.listen_avatar(self, "left")

		elseif btn.id == "next_avatar" then
			game_constructor_player_selects.listen_avatar(self, 'right')

		elseif btn.id == "prev_bot" then
			game_constructor_player_selects.listen_bot(self, "left")

		elseif btn.id == "next_bot" then
			game_constructor_player_selects.listen_bot(self, 'right')

		end
	end

	if gui_input.on_input(self, action_id, action, function_focus, function_activate, function_back, function_post_focus) then
		return true
	end

	if (gui_input.is_touch(self, action_id, action) or (action.x and action.y)) and gui.pick_node(self.nodes.btn_close, action.x, action.y) then
		return true
	end

end

function on_reload(self)

end

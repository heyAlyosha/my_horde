local druid = require("druid.druid")
local gui_input = require "main.gui.modules.gui_input"
local storage_gui = require "main.storage.storage_gui"
local storage_player = require "main.storage.storage_player"
local gui_animate = require "main.gui.modules.gui_animate"
local game_constructor_score = require "main.gui.game_gui.game_constructor.modules.game_constructor_score"
local game_constructor_btns = require "main.gui.game_gui.game_constructor.modules.game_constructor_btns"
local gui_manager = require "main.gui.modules.gui_manager"
local game_content_levels = require "main.game.content.game_content_levels"
local game_content_text = require "main.game.content.game_content_text"
local gui_render = require "main.gui.modules.gui_render"
local gui_size = require 'main.gui.modules.gui_size'
local api_player = require 'main.game.api.api_player'
local gui_loyouts = require "main.gui.modules.gui_loyouts"
local gui_lang = require "main.lang.gui_lang"
local nakama_api_account = require "main.online.nakama.api.nakama_api_account"
local censoored_csv = require "main.core.censoored.censoored_csv"
local sound_render = require "main.sound.modules.sound_render"
local game_constructor_render = require "main.gui.game_gui.game_constructor.modules.game_constructor_render"

function init(self)
	msg.post(".", "acquire_input_focus")
	gui.set_render_order(storage_gui.orders.default_screen)
	self.id = "game_constructor"
	gui_manager.add_screen(self.id, msg.url())

	self.nodes = {
		wrap = gui.get_node("wrap"),
		title = gui.get_node("title"),

		score_title = gui.get_node("score_template/title"),
		score_value = gui.get_node("score_template/select_template/text"),
		btn_score_left = gui.get_node("score_template/select_template/left_arrow"),
		btn_score_right = gui.get_node("score_template/select_template/right_arrow"),

		title_players = gui.get_node("title_players"),

		btn_close = gui.get_node("btn-close-template/btn"),
		btn_close_icon = gui.get_node("btn-close-template/btn_icon"),

		btn_play = gui.get_node("btn_play_template/btn"),
		btn_play_icon = gui.get_node("btn_play_template/btn_icon"),
	}

	gui_lang.set_text_upper(self, self.nodes.title, "_settings_family_game")
	gui_lang.set_text(self, self.nodes.score_title, "_score_for_buy_to_shop", nil, ":")
	gui_lang.set_text_upper(self, self.nodes.title_players, "_gamers", nil, ":")

	self.btns = game_constructor_btns.add_btns(self)

	self.druid = druid.new(self)

	gui_input.init(self)
	game_constructor_render.all_players(self)
	game_constructor_score.listen(self)

	gui_input.set_focus(self, 2)

end

function final(self)

	gui_manager.remove_screen(self.id, msg.url())
	self.druid:final()
	gui_input.on_final(self)
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	input_remote_tv.on_message(self, message_id, message, sender)
	gui_loyouts.on_message(self, message_id, message)
	self.druid:on_message(message_id, message, sender)

	if message_id == hash("focus") then
		gui_input.set_focus(self, message.focus)

	elseif message_id == hash("visible") then
		-- Показываем окно
		local data = message.value
		gui_animate.show_bottom(self, self.nodes.wrap , nil)

	elseif message_id == hash("hidden") then
		msg.post("/loader_gui", "visible", {
			id = "keyboard_ru",
			visible = false,
		})

		gui_animate.hidden_bottom(self, self.nodes.wrap, function (self)
			msg.post("/loader_gui", "visible", {
				id = self.id,
				visible = false
			})
		end)

	-- Пришло сообщение
	elseif message_id == hash("set_status") then
		if message.type == "update" then
			game_constructor_render.all_players(self)
		end

	end
end

function on_input(self, action_id, action)
	action_id, action = input_remote_tv.on_input(self, action_id, action)
	self.druid:on_input(action_id, action)

	function function_back(self)
		msg.post("/loader_gui", "visible", {
			id = "keyboard_ru",
			visible = false,
		})
		gui_animate.hidden_bottom(self, self.nodes.wrap, function (self)
			msg.post("/core_screens", "main_menu")
			msg.post("/loader_gui", "visible", {
				id = self.id,
				visible = false
			})
		end)
	end

	if self.focus_btn_id == 1 and action_id == hash("up")  and action.pressed then
		if storage_gui.components_visible.interface then
			msg.post(storage_gui.components_visible.interface, "focus", {focus = 1})
			sound_render.play("focus_main_menu")
		end

		return
	end

	-- Нажатие на кнопки
	local function function_activate(self, focus_btn_id)
		local btn = self.btns[focus_btn_id]

		-- Кнопка заблокирована
		if btn.disabled then
			return false
		end
		
		local node = btn.node or btn.wrap_node or btn.node_bg
		gui_animate.activate(self, node)

		msg.post("main:/sound", "play", {sound_id = "activate_btn"})

		if btn.id == "close" then
			function_back(self)

		elseif btn.id == "prev_score" then
			game_constructor_score.listen(self, 'left')

		elseif btn.id == "next_score" then
			game_constructor_score.listen(self, 'right')

		elseif btn.player_index then
			msg.post("/loader_gui", "visible", {id = "game_constructor_player", visible = true, player_index = btn.player_index})

		elseif btn.id == "play" then
			msg.post("main:/core_family", "event", {id = "constructor_family_play"})

		end
	end

	return gui_input.on_input(self, action_id, action, function_focus, function_activate, function_back, function_post_focus)
end

function on_reload(self)

end

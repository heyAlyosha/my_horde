local druid = require("druid.druid")
local gui_input = require "main.gui.modules.gui_input"
local storage_gui = require "main.storage.storage_gui"
local storage_player = require "main.storage.storage_player"
local gui_animate = require "main.gui.modules.gui_animate"
local modal_settings_color = require "main.gui.modals.modal_settings.modules.modal_settings_color"
local modal_settings_btns = require "main.gui.modals.modal_settings.modules.modal_settings_btns"
local gui_manager = require "main.gui.modules.gui_manager"
local game_content_levels = require "main.game.content.game_content_levels"
local game_content_text = require "main.game.content.game_content_text"
local gui_render = require "main.gui.modules.gui_render"
local gui_size = require 'main.gui.modules.gui_size'
local api_player = require 'main.game.api.api_player'
local gui_loyouts = require "main.gui.modules.gui_loyouts"
local gui_lang = require "main.lang.gui_lang"
local nakama_api_account = require "main.online.nakama.api.nakama_api_account"
local censoored_csv = require "main.core.censoored.censoored_csv"
local sound_render = require "main.sound.modules.sound_render"
local storage_sdk = require "main.storage.storage_sdk"
local storage_gui = require "main.storage.storage_gui"
local storage_game = require "main.game.storage.storage_game"

function init(self)
	msg.post(".", "acquire_input_focus")
	gui.set_render_order(storage_gui.orders.modal + 2)
	self.id = "modal_settings"
	
	gui_manager.add_screen(self.id, msg.url())

	self.nodes = {
		wrap = gui.get_node("wrap"),

		btn_close = gui.get_node("btn-close-template/btn"),
		btn_close_icon = gui.get_node("btn-close-template/btn_icon"),

		--btn_save_name = gui.get_node("name_template/input_template/save_btn_template/btn_wrap"),
		--btn_save_name_title = gui.get_node("name_template/input_template/save_btn_template/btn_title"),
		--id_value = gui.get_node("id_template/value"),

		title = gui.get_node("title"),
		--id_title = gui.get_node("id_template/title"),
		
		--name_title = gui.get_node("name_template/title"),
		--color_title = gui.get_node("color_template/title"),
		volume_music_title = gui.get_node("volume_music_template/title"),
		volume_effects_title = gui.get_node("volume_effects_template/title"),

		btn_reset = gui.get_node("btn_reset_template/btn_wrap"),
		btn_reset_title = gui.get_node("btn_reset_template/btn_title"),
	}

	gui_lang.set_text_upper(self, self.nodes.title, "_settings")
	--gui_lang.set_text(self, self.nodes.id_title, "_id_to_game")
	--gui_lang.set_text(self, self.nodes.name_title, "_name_to_game")
	--gui_lang.set_text_upper(self, self.nodes.btn_save_name_title, "_save")
	--gui_lang.set_text(self, self.nodes.color_title, "_color_player_to_game")
	gui_lang.set_text(self, self.nodes.volume_music_title, "_volume_music")
	gui_lang.set_text(self, self.nodes.volume_effects_title, "_volume_effects")

	self.btns = modal_settings_btns.add_btns(self)

	gui_input.set_focus(self, 1)

	self.druid = druid.new(self)

	gui_input.init(self)
	--self.druid:new_text(self.nodes.id_value, storage_player.id)

	-- Начинаем устанавливать значения
	-- Цвет
	local settings = api_player.get_settings(self)
	local volume_music = settings.volume_music or 0.5
	local volume_effects = settings.volume_effects or 0.5
	--local name = storage_player.name or  ''
	--self.current_color_name = settings.color 
	self.settings = settings

	--modal_settings_color.listen(self)

	-- Имя
	--self.btns_id.edit_name.input:set_text(name)

	-- Громкость
	self.btns_id.music.slider:set(volume_music)
	self.btns_id.effects.slider:set(volume_effects)

	-- Вешаем функции на изменение контента
	-- Изменение громкости
	self.btns_id.music.on = function (self, procent)
		self.settings.volume_music = procent
		msg.post("main:/music", "volume", {volume = procent})
	end
	self.btns_id.effects.on = function (self, procent)
		self.settings.volume_effects = procent
		msg.post("main:/sound", "volume", {volume = procent})
		timer.delay(0.05, false, function (self)
			sound_render.play("focus_main_menu")
		end)
	end

	-- максимальная длина имени
	--[[
	self.btns_id.edit_name.input:set_max_length(30)
	self.btns_id.edit_name.on_input_select = function (self, btn, node)
		if not storage_sdk.edit_name then
			btn.set_status(self, "_no_edit_name_platform")
		else
			btn.set_status(self, "_set_name_msg")
		end
	end
	

	-- Обучение
	self.btns_id.study.set(self, self.settings.study)
	self.btns_id.study.on = function (self, value)
		self.settings.study = value
	end

	-- Напоминания про магазин, между раундами
	self.btns_id.help_shop.set(self, self.settings.help_shop)
	self.btns_id.help_shop.on = function (self, value)
		self.settings.help_shop = value
	end
	--]]
end

function final(self)
	msg.post("main:/core_player", "save_settings", {
		--color = self.current_color_name,
		volume_music = self.settings.volume_music,
		volume_effects = self.settings.volume_effects,
		--study = self.settings.study,
		--help_shop = self.settings.help_shop,
	})
	pprint(self.settings)

	msg.post("/loader_gui", "visible", {
		id = "bg",
		parent_id = self.id,
		visible = false,
		type = hash("animated_close"),
		value = {order = 5}
	})

	gui_manager.remove_screen(self.id, msg.url())
	self.druid:final()
	gui_input.on_final(self)
end

function update(self, dt)
	self.druid:update(dt)
end

function on_message(self, message_id, message, sender)
	input_remote_tv.on_message(self, message_id, message, sender)
	gui_loyouts.on_message(self, message_id, message)
	self.druid:on_message(message_id, message, sender)

	if message_id == hash("focus") then
		gui_input.set_focus(self, message.focus)

	elseif message_id == hash("visible") then
		-- Показываем окно
		local data = message.value
		gui_animate.show_bottom(self, self.nodes.wrap , function (self)
			timer.delay(0.2, false, function (self)
				gui_input.set_focus(self, 1)
			end)
			
		end)

		msg.post("/loader_gui", "visible", {
			id = "bg",
			visible = true,
			parent_id = self.id,
			value = {order = 5},
			type = hash("animated_close"),
		})
	-- Пришло сообщение
	elseif message_id == hash("set_status") then
		if message.type == "result_set_name" then
			local value = message.value
			if value.status == "error" then
				-- Сообщение ошибки
				local id_error_msg
				if value.msg then
					id_error_msg = "_set_name_error_"..value.msg
				else
					id_error_msg = "_error_default"
				end

				self.btns_id.edit_name.set_status(self, id_error_msg, "red")

			elseif value.status == "success" then
				self.btns_id.edit_name.set_status(self, "_set_name_success", "lime")
			end

			gui_input.set_disabled(self, self.btns_id.save_name, false)
			self.btns_id.edit_name.input:set_text(value.name)
		end

	end
end

function on_input(self, action_id, action)
	action_id, action = input_remote_tv.on_input(self, action_id, action)
	self.druid:on_input(action_id, action)

	function function_back(self)
		gui_animate.hidden_bottom(self, self.nodes.wrap, function (self)
			msg.post("/loader_gui", "visible", {
				id = self.id,
				visible = false
			})
		end)
	end

	-- Нажатие на кнопки
	local function function_activate(self, focus_btn_id)
		local btn = self.btns[focus_btn_id]

		-- Кнопка заблокирована
		if btn.disabled then
			return false
		end

		local node = btn.node or btn.wrap_node or btn.node_bg
		gui_animate.activate(self, node)
		msg.post("main:/sound", "play", {sound_id = "activate_btn"})

		if btn.id == "close" then
			function_back(self)

		elseif btn.id == "prev_color" then
			modal_settings_color.listen(self, 'left')

		elseif btn.id == "next_color" then
			modal_settings_color.listen(self, 'right')

		elseif btn.id == "reset" then
			msg.post("main:/loader_gui", "visible", {id = "modal_reset", visible = true})

		elseif btn.id == "save_name" then
			self.btns_id.edit_name.set_status(self, "_set_name_load")
			gui_input.set_disabled(self, btn, true)
			-- Изменяем имя
			msg.post("main:/core_player", "set_name", {
				name = self.btns_id.edit_name.input:get_text()
			})
		end
	end

	if gui_input.on_input(self, action_id, action, function_focus, function_activate, function_back, function_post_focus) then
		return true
	elseif (gui_input.is_touch(self, action_id, action) or not action_id) and gui.pick_node(self.nodes.wrap, action.x, action.y) then
		return true
	end
end

function on_reload(self)

end

local gui_input = require "main.gui.modules.gui_input"
local gui_loyouts = require "main.gui.modules.gui_loyouts"
local gui_animate = require "main.gui.modules.gui_animate"
local gui_lang = require "main.lang.gui_lang"
local storage_gui = require "main.storage.storage_gui"
local character_dialog_functions = require "main.gui.character_dialog.modules.character_dialog_functions"
local gui_loyouts = require "main.gui.modules.gui_loyouts"
local printer = require "printer.printer"
local gui_animate = require "main.gui.modules.gui_animate"

local styles = {
	default = {
		font_height = 40,
		spacing = -14, -- pixels between letters
		scale = 1.1, -- scale of character
		waving = false, -- if true - do waving by sinus
		color = "#FFFFFF",
		speed = 0.05,
		appear = 0.01,
		shaking = 0, -- shaking power. Set to 0 to disable
		sound = "test",
		can_skip = true,
		shake_on_write = 0, -- when letter appear, shake dialogue screen
	},
	blue = {
		color = "#00FFFF",
	},
	green = {
		color = "#00FF00",
	},
	red = {
		color = "#FF496C",
	},
	orange = {
		color = "#FFCC00",
	},
	yellow = {
		color = "#FEFE22",
	}
}

local images = {
	"image:accuracy_1"
}

function init(self)
	msg.post(".", "acquire_input_focus")

	self.nodes = {
		character_study_wrap = gui.get_node("character_study_wrap"),
		bubble = gui.get_node("bubble"),
		bg = gui.get_node("bg"),
	}
	gui.set_render_order(14)

	self.id = "character_dialog"

	printer.add_styles(styles)

	printer.play_sound = function(name)
		msg.post("main:/sound", "play", {sound_id = "letter"})
	end

	local template_name = "printer_template"
	self.printer = printer.new(self, template_name)

	gui_loyouts.set_enabled(self, self.nodes.character_study_wrap, false)
	gui_loyouts.set_enabled(self, self.nodes.bubble, false)
	gui_loyouts.set_enabled(self, self.nodes.bg, false)

end

function update(self, dt)
	msg.post(".", "acquire_input_focus")
	self.printer:update(dt)

	-- Запоминаем место баббла
	storage_gui.positions[self.id] = storage_gui.positions[self.id] or {}
	storage_gui.positions[self.id].bubble = gui.get_screen_position(gui.get_node("printer_template/text_parent"))
	storage_gui.positions[self.id].continue = gui.get_screen_position(gui.get_node("continue"))

	if self.item then
		if not self.printer.is_print and self.item.is_print == nil then
			-- Сообщение напечаталось
			self.item.is_print = self.printer.is_print

			msg.post("/loader_gui", "set_status", {
				id = "all",
				from_id = self.id, 
				is_from_msg = false,
				type = "is_print",
				value = {
					dialog_id = self.item.dialog_id,
					character_id = self.item.character_id,
				}
			})

			-- Таймер закрытия (если есть)
			if self.item.timer_close then
				if self.item.timer then
					timer.cancel(self.item.timer)
				end

				self.item.timer = timer.delay(self.item.timer_close, false, function ()
					character_dialog_functions.next(self)
				end)
			end
		end
	end
end

function final(self)
	gui_input.on_final(self)
	self.printer:final()
end

function on_message(self, message_id, message, sender)
	input_remote_tv.on_message(self, message_id, message, sender)
	gui_loyouts.on_message(self, message_id, message)

	if message_id == hash("set_content") and message.type == "add_dialog" then
		self.items = message.items
		self.index_items = 0

		-- Делаем текст заглавным и увеличиваем пробелы
		for i, item in ipairs(self.items) do
			item.text = utf8.upper(item.text)

			-- Меняем заглвные плейсхолдеры на прописные
			for key, v in pairs(styles) do
				item.text = utf8.gsub(item.text, "{"..utf8.upper(key).."}", "{"..utf8.lower(key).."}")
			end

			for i, key in ipairs(images) do
				item.text = utf8.gsub(item.text, "{"..utf8.upper(key).."}", "{"..utf8.lower(key).."}")
			end

			item.text = utf8.gsub(item.text, " ", "   ")
		end

		self.block_input = true

		gui_animate.show_bottom(self, self.nodes.character_study_wrap, function (self)
			gui_animate.show_elem_popping(self, self.nodes.bubble, duration, delay, function (self)
				msg.post("main:/sound", "play", {sound_id = "character_dialog_leader"})
				character_dialog_functions.next(self)
				self.block_input = false
			end)
		end)

	elseif message_id == hash("hidden") then
		character_dialog_functions.close(self)

	elseif message_id == hash("layout_changed") then
		if self.item then
			if self.item.timer then
				timer.cancel(self.item.timer)
			end
			self.printer:instant_appear()
			self.index_items = 0
			--local template_name = "printer_template"
			--self.printer = printer.new(self, template_name)
			character_dialog_functions.next(self)
		end
	end
end

function on_input(self, action_id, action)
	--action_id, action = input_remote_tv.on_input(self, action_id, action)
	if not self.block_input and action_id and action.pressed then
		if self.printer.is_print then
			-- Сбрасываем анимацию печатния
			self.printer:instant_appear()
		else
			character_dialog_functions.next(self)
		end

		-- Блокируем управление на время
		self.block_input = true
		timer.delay(0.1, false, function (self)
			self.block_input = false
		end)
	end

	return true
end
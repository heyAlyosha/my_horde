local druid = require("druid.druid")
local gui_size = require "main.gui.modules.gui_size"
local gui_animate = require "main.gui.modules.gui_animate"
local storage_player = require "main.storage.storage_player"
local gui_input = require "main.gui.modules.gui_input"
local gui_loyouts = require "main.gui.modules.gui_loyouts"
local gui_lang = require "main.lang.gui_lang"
local camera = require "orthographic.camera"

function init(self)
	gui.set_render_order(1)
	-- Время на прочтение 1 символа
	self.time_symbol = 0.05
	-- Минимальное время
	self.min_time = 2.25

	self.nodes = {
		bubble = gui.get_node("bubble"),
		bubble_text = gui.get_node("bubble_text"),
	}

	self.druid = druid.new(self)

end

function final(self)
	local no_focus_last_component = true
	gui_input.on_final(self, no_focus_last_component)
end


function on_message(self, message_id, message, sender)
	input_remote_tv.on_message(self, message_id, message, sender)
	if message_id == hash("visible") then
		self.text = message.text or ""
		local side = message.side or "right"
		local position_center_bubble = message.position or vmath.vector3(0)
		local scale_bubble = gui.get_scale(self.nodes.bubble)

		gui.set_scale(self.nodes.bubble, vmath.vector3(storage_player.zoom) * scale_bubble.x)

		position_center_bubble = camera.world_to_screen(camera_id, position_center_bubble, gui.ADJUST_STRETCH)
		--position_center_bubble = gui.screen_to_local(self.nodes.bubble, position_center_bubble)
		
		if side == "left" then
			gui_loyouts.play_flipbook(self, self.nodes.bubble, "Bubble_left")
			-- устанавливаем текст внутри баббла
			gui_loyouts.set_position(self, self.nodes.bubble_text,  -351, "x")

			position_center_bubble.x = position_center_bubble.x + gui.get_size(self.nodes.bubble).x
			--position_center_bubble.x = position_center_bubble.x - 80
			--position_center_bubble.x = position_center_bubble.x + 20

		else
			-- устанавливаем текст внутри баббла
			gui_loyouts.set_position(self, self.nodes.bubble_text,  -391, "x")

			position_center_bubble.x = position_center_bubble.x - 40
			gui_loyouts.play_flipbook(self, self.nodes.bubble, "Bubble_right")
		end

		--gui.set_text(self.nodes.bubble_text, self.text)
		if not self.druid_text then
			self.druid_text = self.druid:new_text(self.nodes.bubble_text, self.text)
		else
			self.druid_text.set_to(self.text)
		end

		-- Определяем позицию баббла
		--position_center_bubble.y = position_center_bubble.y - storage_player.camera_yoffset + 60
		--position_center_bubble.x =  position_center_bubble.x - storage_player.camera_xoffset

		position_center_bubble.y = position_center_bubble.y - 60

		gui_loyouts.set_position(self, self.nodes.bubble, position_center_bubble)

		--pprint("bubble_position", position_center_bubble)


		-- Находим размер текста для бабла
		--[[
		local height_text = 40 + gui_size.get_size_gui_text(self.nodes.bubble_text).height + 40

		if height_text < 200 then
			height_text = 200
		end

		-- Устанавливаем высоту баббла
		gui.animate(self.nodes.bubble, "size.y", height_text, gui.EASING_LINEAR, 0)
		-- Устанавливаем текст внутри баббла
		gui.animate(self.nodes.bubble_text, "position.y", height_text - 40, gui.EASING_LINEAR, 0)
		--]]

		gui_animate.show_elem_popping(self, self.nodes.bubble, duration, delay, function (self)
			--Скрывам через время
			local delay = self.min_time + utf8.len(self.text) * self.time_symbol
			timer.delay(delay, false, function (self)
				msg.post("/loader_gui", "visible", {
					id = "dialog_bubble",
					type = hash("animated_close"),
					visible = false
				})
			end)
		end)

		

	elseif message_id == hash("hidden") then
		gui.animate(self.nodes.bubble, "scale", 0, gui.EASING_LINEAR, 0.25, 0, function (self)
			msg.post("/loader_gui", "visible", {
				id = "dialog_bubble",
				visible = false
			})
		end)
	end
end
